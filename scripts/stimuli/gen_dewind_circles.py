'''

This dataset generator generates binary images of equally sized white circles on black backgrounds. 

Following Dewind et al 2015, there are three orthogonal dimensions along which the generated images differ (placement of the dots in the image notwihstanding): log(numerosity) (the number of dots in an image), log(Size) (ISA*TSA, or equivalently n*ISA^2), and log(Spacing) (FA*Sparsity, or equivalently 1/n * FA^2), where ISA (Individual Surface Area) is the surface area of an individual dot; TSA (Total Surface Area) is n*ISA; FA (Field Area) is the total background area within which all dots are drawn; and Sparsity is FA/n.

By default, stimuli are generated by specifying a list of values for each of the three orthogonal dimensions, as well as the number of images to make for every combination of these three dimensions. The --linear flag can be used to specify numerosity, Size, and Spacing exactly instead of their logs. From there, ISA and FA are calculated for each combination of dimensions and stimuli are generated by randomly choosing a circular region in the image with the calculated FA and then using rejection sampling to generate the right number of dots in that region, each with the calculated ISA. That is, dots are generated sequentially such that the distance between any two dots (or any dot and the edge of the image) is less than the --distance argument. The dimensions of the image in pixels can be specified with the --pic-dim argument.

File names of images, placed in a directory of the /stimuli/ directory, follow the following format:
[numerosity]_[Size]_[Spacing]_[unique image #].png

'''


from PIL import Image, ImageDraw
import random
import numpy as np
import os
import time
import argparse


def gen_origin_in_range(bounding_origin, bounding_side, side):
    x0 = np.random.randint(bounding_origin[0],bounding_origin[0]+bounding_side-side+1)
    y0 = np.random.randint(bounding_origin[1],bounding_origin[1]+bounding_side-side+1)
    return (x0,y0)
    
def intersects(origin1,origin2,min_distance):
    (x0,y0) = origin1
    (x1,y1) = origin2
    x_distance = abs(x0-x1)
    y_distance = abs(y0-y1)
    return (x_distance < min_distance) and (y_distance < min_distance)


def gen_square_origins(num_squares, square_side, pic_dim, square_spacing, bounding_origin, bounding_side):
    retry = True
    while retry:
        retry = False
        square_origins = []
        
        for i in range(1,num_squares+1):
            #get spatial position
            touching = True
            (x0,y0) = gen_origin_in_range(bounding_origin, bounding_side, square_side)
            attempts = 0
            while touching:
                attempts += 1
                touching = False
                for square_origin in square_origins:
                    if intersects((x0,y0),square_origin,square_spacing + square_side):
                        if attempts >= 200:
                            retry = True
                            break
                        touching = True
                        break
            if retry:
                break
            square_origins.append((x0,y0))
    return square_origins



def gen_images(args):

    for num_squares in args.num_squares:
        print(num_squares)
        for pic_index in range(1,args.num_pics_per_category+1):
            img_file_name = f"{num_squares}_{args.square_side}_{args.bounding_side}_{pic_index}.png"
            img = Image.new('1', (args.pic_dim, args.pic_dim), 'black')
            bounding_origin = gen_origin_in_range((0,0),args.pic_dim,args.bounding_side)

            if num_squares > 0:
                square_origins = gen_square_origins(num_squares, args.square_side, args.pic_dim, args.square_spacing, bounding_origin, args.bounding_side)
                for square_origin in square_origins:
                    corners = [square_origin[0],square_origin[1],square_origin[0]+square_side-1,square_origin[1]+square_side-1]#-1 bc annoyingly a (0,0,0,0) rectangle in PIL is a 1x1 rectangle
                    squaredraw = ImageDraw.Draw(img)
                    squaredraw.rectangle(corners, fill='white',outline='white')
            
            if pic_index <= args.num_train_pics_per_category:
                img.save(os.path.join(args.train,img_file_name))
            else:
                img.save(os.path.join(args.test,img_file_name))


if __name__ == '__main__':

    start_time = time.time()

    #Command Line Arguments 
    parser = argparse.ArgumentParser(description='Generate Dewind stimuli')
    parser.add_argument('--dataset_name', type=str, help='Name of dataset directory.')
    parser.add_argument('--pic_dims', nargs=2, metavar=('pic_width', 'pic_height'), type=int, default=[100,100], help='number of pixels for each axis of image')
    parser.add_argument('--linear_args', action='store_true', default=False, help="If this argument is used, interpret numerosities, sizes, and spacings linearly. Otherwise, assume they are log_2 of the actual desired values")
    parser.add_argument('--numerosities', nargs='+', type=int, help='space separated list of the number of dots. Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--sizes', nargs='+', type=int, help='space separated list of the Sizes. Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--spacings', nargs='+', type=int, help='space separated list of the Spacings. Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--distance', type=int, default=3, help='minimum number of pixels between the edges of each dot and between the edge of each dot and the edge of the image.')
    parser.add_argument('--num-pics-per-category', type=int, 
                        help='number of pictures per combination of stimulus parameters')
    parser.add_argument('--num-train-pics-per-category', type=int,
                        help='number of training pictures per combination of stimulus parameters')
    

    args = parser.parse_args()
    # reconcile arguments
    if not args.linear_args:
        def square_all(l):
            return [2**x for x in l]
        args.numerosities = square_all(args.numerosities)
        args.sizes = square_all(args.sizes)
        args.spacings = square_all(args.spacings)


    dataset_name = args.dataset_name+'_dewind_circles_'+time.strftime('%m-%d-%Y:%H_%M')
    if not os.path.exists(os.path.join('../../stimuli',dataset_name)):
        os.mkdir(os.path.join('../../stimuli',dataset_name))
    outputdir = os.path.join('../../stimuli',dataset_name)
    with os.path.join(outputdir,'args.txt') as f:
        f.write(args)
    os.mkdir(os.path.join(outputdir,'train'))
    train_dir = os.path.join(outputdir,'train')
    os.mkdir(os.path.join(outputdir,'test'))
    test_dir = os.path.join(outputdir,'test')

    print('running with args:')
    print(args)

    for size in args.sizes:
        print(f"Size: {size}")
        for spacing in args.spacings:
            print(f"Spacing: {spacing}")
            gen_images()

    end_time = time.time()
    print('Run Time: %s'%(end_time-start_time))

