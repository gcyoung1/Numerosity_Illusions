'''

This dataset generator generates binary images of equally sized white circles on black backgrounds. 

Following Dewind et al 2015, there are three orthogonal dimensions along which the generated images differ (placement of the dots in the image notwihstanding): log(numerosity), where numerosity is the number of dots in the image; log(Size), where Size = ISA*TSA, or equivalently n*ISA^2; and log(Spacing), where Spacing = FA*Sparsity, or equivalently 1/n * FA^2; where ISA (Individual Surface Area) is the surface area of each individual dot in the image, TSA (Total Surface Area) is n*ISA, FA (Field Area) is the total background area within which all dots are drawn, and Sparsity is FA/n.

By default, stimuli are generated by specifying a list of values for each of the three orthogonal dimensions, as well as the number of images to make for every combination of these three dimensions. The --linear flag can be used to specify numerosity, Size, and Spacing exactly instead of their logs. From there, ISA and FA are calculated for each combination of dimensions and stimuli are generated by randomly choosing a circular region in the image with the calculated FA and then using rejection sampling to generate the right number of dots in that region, each with the calculated ISA. That is, dots are generated sequentially such that the distance between any two dots (or any dot and the edge of the image) is less than the --distance argument. The dimensions of the image in pixels can be specified with the --pic_dim argument.

File names of images, placed in a directory of the /stimuli/ directory, follow the following format:
[numerosity]_[Size]_[Spacing]_[unique image #].png

'''


from PIL import Image, ImageDraw
import numpy as np
import os
import time
import argparse
import math
from .geometry_utils import polar_to_cartesian, radius_from_area
from .circle import Circle
from .line import Line

def gen_circle_in_field(field, individual_radius):
    # Since the circumference of circle grows linearly with the radius,
    # the probability of choosing a point at a certain radius must
    # increase linearly with the radius in order to keep the density
    # constant throughout the circle.
    # Let r in [0,1] be a multiplier which controls what fraction of our max raidus we select
    # PDF f_x(r) = 2r has a linear slope from r=0 to r=1
    # CDF F_x(r) = r**2, integral of PDF
    # Inverse CDF F_x**(-1)(u) = u**(1/2) gives r for which P(r' <= r) = u
    # Thus we can turn uniform random u ~ U[0,1] into r from our target distribution
    # See https://www.youtube.com/watch?v=4y_nmpv-9lI for a better explanation

    max_valid_radius = field.radius-individual_radius # Maximum distance from the center of the field
    u = np.random.random() # u ~ U[0,1], uniform random variable
    r = u **(1/2) # r = F_x**(-1)(u) 
    radius = max_valid_radius * r # Multiply by max to get actual radius
    theta = np.random.uniform(0,360)
    individual_center = field.center + polar_to_cartesian(radius, theta)
    return Circle(individual_center, individual_radius)

def gen_circles(numerosity, size, spacing, min_distance, pic_width, pic_height):
    individual_surface_area = (size/numerosity)**(1/2)
    individual_radius = radius_from_area(individual_surface_area)
    field_area = (spacing*numerosity)**(1/2)
    field_radius = radius_from_area(field_area)
    field = gen_circle_in_rectangle(pic_width/2,pic_height/2,pic_width,pic_height,field_radius,min_distance)

    # NB This will infinite loop if the input parameters are impossible to satisfy
    while True:
        circles = []
        for _ in range(numerosity):
            # Try to generate a new circle 2000 times
            for attempt in range(2000):
                circle = gen_circle_in_field(field, individual_radius)
                untouched = True
                for other_circle in circles:
                    if circle.distance_from(other_circle) < min_distance:
                        untouched = False
                # Break out early if you succeed
                if untouched: 
                    break
            # If you didn't succeed in time, go back to the beginning and try again
            if attempt == 1999:
                break
            # Otherwise add to your list of circles and return if you have all you need
            circles.append(circle)
            if len(circles) == numerosity:
                return circles

def gen_circle_in_rectangle(x_center,y_center,rect_width,rect_height,radius, min_distance):
    edge_buffer = (radius + min_distance) # How many pixels from the edge of the recetangle your circle's center can be
    # Maximum distance from the center of the rectangle your circle's center can be, in both directions
    max_x_change = (rect_width/2) - edge_buffer  
    max_y_change = (rect_height/2) - edge_buffer
    x = np.random.uniform(x_center-max_x_change,x_center+max_x_change)
    y = np.random.uniform(y_center-max_y_change,y_center+max_y_change)
    center = np.array([x,y])
    return Circle(center, radius)

def draw_circles(circles, hollow, pic_width, pic_height):
    img = Image.new('1', (pic_width, pic_height), 'black')
    for circle in circles:
        corners = circle.corners()
        circledraw = ImageDraw.Draw(img)
        if hollow:
            fill_color = 'black'
        else: 
            fill_color = 'white'
        circledraw.ellipse(corners, fill=fill_color, outline='white')
    return img

def intersects_other_circles(circles, line, line_dist):
    for i, circle in enumerate(circles):
        if line.distance_to_point(circle.center) < (circle.radius + line_dist):
            return True
    return False

def intersects_other_lines(lines, line):
    for existing_line in lines:
        if line.intersects(existing_line):
            return True
    return False

def gen_lines(circles, num_lines, line_length_range, line_width, line_dist):

    while True:
        unconnected_circle_indices = list(range(len(circles)))
        lines = []
        for _ in range(num_lines):
            # Try to generate a new line 2000 times
            for attempt in range(2000):
                idx1, idx2 = np.random.choice(unconnected_circle_indices, 2, replace=False)
                line = Line(circles[idx1].center, circles[idx2].center)
                line_valid = True
                #Line valid length
                if line.length < line_length_range[0] or line.length > line_length_range[1]:
                    line_valid = False
                # Doesn't intersect other circles
                other_circles = [x for i, x in enumerate(circles) if i not in [idx1, idx2]]
                if intersects_other_circles(other_circles, line, line_dist):
                    line_valid = False
                # Doesn't intersect other lines
                if intersects_other_lines(lines, line):
                    line_valid = False

                # Break out early if you succeed
                if line_valid: 
                    break
            # If you didn't succeed in time, go back to the beginning and try again
            if attempt == 1999:
                break
            # Otherwise add to your list of lines and return if you have all you need
            lines.append(line)
            unconnected_circle_indices = [x for x in unconnected_circle_indices if not x in [idx1, idx2]]
            if len(lines) == num_lines:
                return lines

def draw_lines(img, lines, line_width, illusory):
    for line in lines:
        linedraw = ImageDraw.Draw(img)
        if illusory:
            line_color = 'black'
        else:
            line_color = 'white'
        linedraw.line(line.endpoints(), fill=line_color, width=line_width)
    return img

if __name__ == '__main__':

    start_time = time.time()

    #Command Line Arguments 
    parser = argparse.ArgumentParser(description='Generate Dewind stimuli')
    parser.add_argument('--experiment_name', type=str, help='Name of experiment directory.')
    parser.add_argument('--dataset_name', type=str, help='Name of dataset directory within experiment directory.')
    parser.add_argument('--pic_width', type=int, default=227, help='number of pixels for width of image. Default = 227')
    parser.add_argument('--pic_height', type=int, default=227, help='number of pixels for height of image. Default = 227')
    parser.add_argument('--linear_args', action='store_true', default=False, help="If this argument is used, interpret numerosities, sizes, and spacings linearly. Otherwise, assume they are log_2 of the actual desired values")
    parser.add_argument('--numerosities', nargs='+', type=float, help='space-separated list of the Numerosities (number of dots). Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--sizes', nargs='+', type=float, help='space-separated list of the Sizes. Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--spacings', nargs='+', type=float, help='space-separated list of the Spacings. Log_2 scaled by default: use the --linear_args argument to interpret linearly.')
    parser.add_argument('--min_distance', type=int, default=2, help='minimum number of pixels between the edges of each dot and between the edge of each dot and the edge of the image. Default = 2.')
    parser.add_argument('--num_pics_per_category', type=int, 
                        help='number of pictures per combination of stimulus parameters')
    parser.add_argument('--hollow', action='store_true', default=False, help="if this argument is used, make the circles hollow (ie make the fill color be the background color).")

    parser.add_argument('--num_lines', type=int, default=0,
                        help='Space-separated list of the number of lines which connect pairs of dots.')
    parser.add_argument('--line_length_range', nargs=2, default=[2, 30], type=int, help='minimum dot radius and maximum dot radius separated by a space. Default = 2 30.')
    parser.add_argument('--line_dist', type=int, default=2, help='minimum number of pixels between lines and dots')
    parser.add_argument('--line_width', type=int, default=2, help='width of lines')
    parser.add_argument('--illusory', action='store_true', default=False, help='if this argument is used, make connecting lines the same color as the background (ie illusory contours)')


    args = parser.parse_args()
    # reconcile arguments
    if not args.linear_args:
        def exponentiate(l):
            return [round(2**x) for x in l]
        args.numerosities = exponentiate(args.numerosities)
        args.sizes = exponentiate(args.sizes)
        args.spacings = exponentiate(args.spacings)
    else:
        def int_cast(l):
            return [int(x) for x in l]
        args.numerosities = int_cast(args.numerosities)
        args.sizes = int_cast(args.sizes)
        args.spacings = int_cast(args.spacings)

    # Get path to stimuli directory
    file_path = os.path.dirname(os.path.realpath(__file__))

    experiment_path = os.path.join(file_path,'../../data/stimuli',args.experiment_name)
    if not os.path.exists(experiment_path):
        os.mkdir(experiment_path)
    dataset_path = os.path.join(experiment_path, args.dataset_name)
    os.mkdir(dataset_path)

    stim_path = os.path.join(dataset_path,'stimuli')
    os.mkdir(stim_path)

    with open(os.path.join(dataset_path,'args.txt'), 'w') as argsfile:
        argsfile.write(str(args))
    print('running with args:')
    print(args)

    for numerosity in args.numerosities:
        print(numerosity)
        for size in args.sizes:
            print(f"Size: {size}")
            for spacing in args.spacings:
                print(f"Spacing: {spacing}")
                for pic_index in range(1,args.num_pics_per_category + 1):
                    circles = gen_circles(numerosity, size, spacing, args.min_distance, args.pic_width, args.pic_height)
                    img = draw_circles(circles, args.hollow, args.pic_width, args.pic_height)
                    if args.num_lines > 0:
                        lines = gen_lines(circles, args.num_lines, args.line_length_range, args.line_width, args.line_dist)
                        img = draw_lines(img, lines, args.line_width, args.illusory)
                    img_file_name = f"{numerosity}_{size}_{spacing}_{args.num_lines}_{pic_index}.png"
                    img.save(os.path.join(stim_path,img_file_name))

    end_time = time.time()
    print('Run Time: %s'%(end_time-start_time))

